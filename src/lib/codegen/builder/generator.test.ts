import { expect, describe, it } from "bun:test";
import {
    GraphQLID,
    GraphQLObjectType,
    GraphQLSchema,
    GraphQLString,
} from "graphql";
import { type CodegenOptions } from "./meta";
import { Generator } from "./generator";
import { GeneratorSelectionTypeFlavorDefault } from "../flavors/default/generator-flavor";

describe("Generator", () => {
    describe("generate", () => {
        it("should generate the query builder's code", async () => {
            const schema = new GraphQLSchema({
                query: new GraphQLObjectType({
                    name: "Query",
                    fields: {
                        user: {
                            type: new GraphQLObjectType({
                                name: "User",
                                fields: {
                                    id: {
                                        type: GraphQLID,
                                    },
                                    name: { type: GraphQLString },
                                },
                            }),
                        },
                    },
                }),
            });

            // Arrange
            const options: CodegenOptions = {};

            // Act
            const result = await new Generator(
                GeneratorSelectionTypeFlavorDefault,
            ).generate({ schema, options });

            // Assert
            expect(result).toBe(
                'const Proxy = global.Proxy;\nProxy.prototype = {};\n\nexport class RootOperation {\n    private utilSet = (obj: Record<string, any>, path: string[], value: any) =>\n        path.reduce(\n            (o, p, i, a) => (o[p] = a.length - 1 === i ? value : o[p] || {}),\n            obj,\n        );\n\n    private rootCollector: OperationSelectionCollector | undefined = undefined;\n    public registerRootCollector(collector: OperationSelectionCollector) {\n        this.rootCollector = collector;\n    }\n    public async execute() {\n        if (!this.rootCollector) {\n            throw new Error("RootOperation has no registered collector");\n        }\n\n        type selection = ReturnType<\n            typeof OperationSelectionCollector.prototype.renderSelections\n        >;\n        const operations: { [key: string]: selection } = {};\n        for (const [\n            opName,\n            opSelection,\n        ] of this.rootCollector?.selections.entries()) {\n            operations[opName] = opSelection[SLW_COLLECTOR]!.renderSelections([\n                opName,\n            ]);\n        }\n\n        const ops = Object.entries(operations).reduce(\n            (acc, [opName, op]) => ({\n                ...acc,\n                [opName]: {\n                    query: `${this.rootCollector!.selections.get(opName)?.[\n                        SLW_FIELD_TYPE\n                    ]?.toLowerCase()} ${opName} ${\n                        op.variableDefinitions.length\n                            ? `(${op.variableDefinitions.join(", ")})`\n                            : ""\n                    } ${op.selection}\n                    `,\n                    variables: op.variables,\n                },\n            }),\n            {} as Record<string, { query: string; variables: any }>,\n        );\n        // const subscription = `{${subscriptions.join("")}}`;\n\n        const results = Object.fromEntries(\n            await Promise.all([\n                ...Object.entries(ops).map(\n                    async ([opName, op]) =>\n                        [opName, await this.executeOperation(op)] as const,\n                ),\n            ]),\n        );\n\n        return results;\n    }\n\n    private async executeOperation(query: { query: string; variables: any }) {\n        const res = await fetch("https://spacex-production.up.railway.app/", {\n            method: "POST",\n            headers: {\n                "Content-Type": "application/json",\n            },\n            body: JSON.stringify({\n                query: query.query,\n                variables: query.variables,\n            }),\n        });\n        const result = await res.json();\n\n        const { data, errors } = result ?? {};\n        if (errors?.length > 0) {\n            for (const error of errors) {\n                if (error.path) {\n                    this.utilSet(data, error.path, error);\n                }\n            }\n        }\n        return data;\n    }\n}\nexport class OperationSelectionCollector {\n    constructor(\n        public readonly name?: string,\n        public readonly parent?: OperationSelectionCollector,\n        public readonly op?: RootOperation,\n    ) {\n        if (op) op.registerRootCollector(this);\n    }\n\n    private executed = false;\n    private operationResult: any | undefined = undefined;\n    public async execute() {\n        if (!this.op) {\n            throw new Error(\n                "OperationSelectionCollector is not registered to a root operation",\n            );\n        }\n        this.operationResult = await this.op.execute();\n        this.executed = true;\n    }\n    public get isExecuted() {\n        return this.executed;\n    }\n\n    public readonly selections = new Map<\n        string,\n        SelectionWrapperImpl<string, string, any>\n    >();\n    public registerSelection(\n        id: string,\n        selection: SelectionWrapperImpl<string, string, any>,\n    ) {\n        this.selections.set(id, selection);\n    }\n\n    public renderSelections(\n        path: string[] = [],\n        opVars: Record<string, any> = {},\n    ) {\n        const result: Record<string, any> = {};\n        const varDefs: string[] = [];\n        const variables: Record<string, any> = {};\n\n        for (const [key, value] of this.selections.entries()) {\n            const subPath = [...path, key];\n            const {\n                selection: fieldSelection,\n                variableDefinitions: fieldVarDefs,\n                variables: fieldVars,\n            } = value[SLW_RENDER_WITH_ARGS](opVars);\n\n            Object.assign(variables, fieldVars);\n            Object.assign(opVars, fieldVars);\n            varDefs.push(...fieldVarDefs);\n            value[SLW_REGISTER_PATH](subPath);\n\n            if (value[SLW_PARENT_COLLECTOR] === undefined) {\n                result[key] = fieldSelection;\n            } else if (\n                value[SLW_COLLECTOR] instanceof OperationSelectionCollector\n            ) {\n                const {\n                    selection: subSelection,\n                    variableDefinitions: subVarDefs,\n                    variables: subVars,\n                } = value[SLW_COLLECTOR].renderSelections(subPath, opVars);\n\n                result[key] = `${fieldSelection} ${subSelection}`;\n\n                Object.assign(variables, subVars);\n                Object.assign(opVars, subVars);\n                varDefs.push(...subVarDefs);\n            }\n        }\n        let rendered = "{ ";\n        for (const [key, value] of Object.entries(result)) {\n            const isSubSelection = value.toString().startsWith("{");\n            if (key === value) {\n                rendered += `${key} `;\n            } else {\n                rendered += `${key}${!isSubSelection ? ":" : ""} ${value} `;\n            }\n        }\n        rendered += " }";\n        return {\n            selection: rendered,\n            variableDefinitions: varDefs,\n            variables,\n        };\n    }\n\n    private utilGet = (obj: Record<string, any>, path: string[]) =>\n        path.reduce((o, p) => o?.[p], obj);\n    public getOperationResultPath<T>(path: string[] = []): T {\n        if (!this.op) {\n            throw new Error(\n                "OperationSelectionCollector is not registered to a root operation",\n            );\n        }\n\n        if (path.length === 0) return this.operationResult as T;\n\n        return this.utilGet(this.operationResult, path) as T;\n    }\n}\n\nexport const SLW_UID = Symbol("SLW_UID");\nexport const SLW_FIELD_NAME = Symbol("SLW_FIELD_NAME");\nexport const SLW_FIELD_TYPE = Symbol("SLW_FIELD_TYPE");\nexport const SLW_VALUE = Symbol("SLW_VALUE");\nexport const SLW_ARGS = Symbol("SLW_ARGS");\nexport const SLW_ARGS_META = Symbol("SLW_ARGS_META");\nexport const OP = Symbol("OP");\nexport const ROOT_OP_COLLECTOR = Symbol("ROOT_OP_COLLECTOR");\nexport const SLW_PARENT_COLLECTOR = Symbol("SLW_PARENT_COLLECTOR");\nexport const SLW_COLLECTOR = Symbol("SLW_COLLECTOR");\nexport const SLW_OP_PATH = Symbol("SLW_OP_PATH");\nexport const SLW_REGISTER_PATH = Symbol("SLW_REGISTER_PATH");\nexport const SLW_RENDER_WITH_ARGS = Symbol("SLW_RENDER_WITH_ARGS");\n\nexport class SelectionWrapperImpl<\n    fieldName extends string,\n    typeName extends string,\n    valueT extends any = any,\n    argsT extends Record<string, any> | undefined = undefined,\n> {\n    private generateUniqueId(): string {\n        return (\n            performance.now().toString(36) +\n            Math.random().toString(36).substring(2)\n        );\n    }\n\n    readonly [SLW_UID] = this.generateUniqueId();\n    readonly [ROOT_OP_COLLECTOR]?: OperationSelectionCollector;\n    readonly [SLW_PARENT_COLLECTOR]?: OperationSelectionCollector;\n    readonly [SLW_COLLECTOR]?: OperationSelectionCollector;\n\n    [SLW_FIELD_NAME]?: fieldName;\n    [SLW_FIELD_TYPE]?: typeName;\n    [SLW_VALUE]?: valueT;\n\n    [SLW_ARGS]?: argsT;\n    [SLW_ARGS_META]?: Record<string, string>;\n\n    constructor(\n        fieldName?: fieldName,\n        typeName?: typeName,\n        value?: valueT,\n        collector?: OperationSelectionCollector,\n        parent?: OperationSelectionCollector | RootOperation,\n        args?: argsT,\n        argsMeta?: Record<string, string>,\n    ) {\n        this[SLW_FIELD_NAME] = fieldName;\n        this[SLW_FIELD_TYPE] = typeName;\n        this[SLW_VALUE] = value;\n\n        this[SLW_ARGS] = args;\n        this[SLW_ARGS_META] = argsMeta;\n\n        if (parent instanceof OperationSelectionCollector) {\n            this[SLW_PARENT_COLLECTOR] = parent;\n        }\n        if (collector instanceof OperationSelectionCollector) {\n            this[SLW_COLLECTOR] = collector;\n\n            let rootCollector = collector;\n            while (rootCollector?.parent) {\n                rootCollector = rootCollector.parent;\n            }\n            this[ROOT_OP_COLLECTOR] = rootCollector;\n        }\n    }\n\n    [SLW_OP_PATH]?: string;\n    [SLW_REGISTER_PATH](path: string[]) {\n        if (!this[SLW_OP_PATH]) this[SLW_OP_PATH] = path.join(".");\n    }\n    [SLW_RENDER_WITH_ARGS](opVars: Record<string, any> = {}) {\n        if (this[SLW_ARGS]) {\n            const args = this[SLW_ARGS];\n            const argsMeta = this[SLW_ARGS_META]!;\n\n            const argToVarMap: Record<string, string> = {};\n            let argsString = "(";\n            for (const key of Object.keys(args)) {\n                let varName = key;\n                if (opVars[key] !== undefined) {\n                    varName = `${key}_${\n                        Object.keys(opVars).filter((k) => k.startsWith(key))\n                            .length\n                    }`;\n                    argToVarMap[varName] = varName;\n                    args[varName] = args[key];\n                    argsMeta[varName] = argsMeta[key];\n                    delete args[key];\n                    delete argsMeta[key];\n                }\n                argsString += `${key}: $${varName} `;\n            }\n            argsString += ")";\n            return {\n                selection: `${this[SLW_FIELD_NAME]}${argsString}`,\n                variables: args,\n                variableDefinitions: Object.keys(args).map((key) => {\n                    const varName = argToVarMap[key] ?? key;\n                    return `$${varName}: ${argsMeta[key]}`;\n                }),\n            };\n        }\n        return {\n            selection: this[SLW_FIELD_NAME],\n            variables: {},\n            variableDefinitions: [] as string[],\n        };\n    }\n}\nexport class SelectionWrapper<\n    fieldName extends string,\n    typeName extends string,\n    valueT extends any = any,\n    argsT extends Record<string, any> | undefined = undefined,\n> extends Proxy<SelectionWrapperImpl<fieldName, typeName, valueT, argsT>> {\n    constructor(\n        fieldName?: fieldName,\n        typeName?: typeName,\n        value?: valueT,\n        collector?: OperationSelectionCollector,\n        parent?: OperationSelectionCollector,\n        args?: argsT,\n        argsMeta?: Record<string, string>,\n    ) {\n        super(\n            new SelectionWrapperImpl<fieldName, typeName, valueT, argsT>(\n                fieldName,\n                typeName,\n                value,\n                collector,\n                parent,\n                args,\n                argsMeta,\n            ),\n            {\n                // implement ProxyHandler methods\n                ownKeys() {\n                    return Reflect.ownKeys(value ?? {});\n                },\n                getOwnPropertyDescriptor(target, prop) {\n                    return Reflect.getOwnPropertyDescriptor(value ?? {}, prop);\n                },\n                has(target, prop) {\n                    if (prop === Symbol.for("nodejs.util.inspect.custom"))\n                        return true;\n                    return Reflect.has(value ?? {}, prop);\n                },\n                get: (target, prop) => {\n                    if (\n                        prop === SLW_UID ||\n                        prop === SLW_FIELD_NAME ||\n                        prop === SLW_FIELD_TYPE ||\n                        prop === SLW_VALUE ||\n                        prop === SLW_ARGS ||\n                        prop === SLW_ARGS_META ||\n                        prop === ROOT_OP_COLLECTOR ||\n                        prop === SLW_PARENT_COLLECTOR ||\n                        prop === SLW_COLLECTOR ||\n                        prop === SLW_OP_PATH ||\n                        prop === SLW_REGISTER_PATH ||\n                        prop === SLW_RENDER_WITH_ARGS\n                    ) {\n                        return target[\n                            prop as keyof SelectionWrapperImpl<\n                                fieldName,\n                                typeName,\n                                valueT\n                            >\n                        ];\n                    }\n                    if (prop === SLW_VALUE) {\n                        return value;\n                    }\n                    if (prop === "then") {\n                        return this;\n                    }\n\n                    let slw_value = target[SLW_VALUE] as\n                        | Record<string, any>\n                        | undefined;\n\n                    if (target[ROOT_OP_COLLECTOR]?.isExecuted) {\n                        const getResultDataForTarget = (\n                            t: SelectionWrapperImpl<\n                                fieldName,\n                                typeName,\n                                valueT,\n                                argsT\n                            >,\n                        ): valueT | undefined => {\n                            const data = t[\n                                ROOT_OP_COLLECTOR\n                            ]!.getOperationResultPath<valueT>(\n                                t[SLW_OP_PATH]?.split(".") ?? [],\n                            );\n                            return data;\n                        };\n\n                        if (!Object.hasOwn(slw_value ?? {}, String(prop))) {\n                            const data = getResultDataForTarget(target);\n                            if (data === undefined) return undefined;\n                            const proto = Object.getPrototypeOf(data);\n                            if (Object.hasOwn(proto, prop)) {\n                                const v = (data as any)[prop];\n                                if (typeof v === "function")\n                                    return v.bind(data);\n                                return v;\n                            }\n                            return () => data;\n                        }\n\n                        const slw = slw_value?.[String(prop)];\n\n                        if (\n                            slw instanceof SelectionWrapperImpl &&\n                            slw[SLW_PARENT_COLLECTOR]\n                        ) {\n                            return slw;\n                        } else if (slw instanceof SelectionWrapperImpl) {\n                            return getResultDataForTarget(slw);\n                        }\n\n                        return getResultDataForTarget(target);\n                    }\n\n                    if (\n                        Object.hasOwn(slw_value ?? {}, String(prop)) &&\n                        slw_value?.[String(prop)] instanceof\n                            SelectionWrapperImpl\n                    ) {\n                        if (target[SLW_COLLECTOR]) {\n                            target[SLW_COLLECTOR].registerSelection(\n                                String(prop),\n                                slw_value[String(prop)],\n                            );\n                        }\n                    }\n\n                    return slw_value?.[String(prop)] ?? undefined;\n                },\n            },\n        );\n    }\n}\n\ntype SelectionFnParent =\n    | {\n          collector: OperationSelectionCollector;\n          fieldName?: string;\n          args?: Record<string, any>;\n          argsMeta?: Record<string, string>;\n      }\n    | undefined;\n\nexport type __TypeKind =\n    | "SCALAR"\n    | "OBJECT"\n    | "INTERFACE"\n    | "UNION"\n    | "ENUM"\n    | "INPUT_OBJECT"\n    | "LIST"\n    | "NON_NULL";\nexport enum __TypeKindEnum {\n    /** Indicates this type is a scalar. */\n    SCALAR = "SCALAR",\n    /** Indicates this type is an object. `fields` and `interfaces` are valid fields. */\n    OBJECT = "OBJECT",\n    /** Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields. */\n    INTERFACE = "INTERFACE",\n    /** Indicates this type is a union. `possibleTypes` is a valid field. */\n    UNION = "UNION",\n    /** Indicates this type is an enum. `enumValues` is a valid field. */\n    ENUM = "ENUM",\n    /** Indicates this type is an input object. `inputFields` is a valid field. */\n    INPUT_OBJECT = "INPUT_OBJECT",\n    /** Indicates this type is a list. `ofType` is a valid field. */\n    LIST = "LIST",\n    /** Indicates this type is a non-null. `ofType` is a valid field. */\n    NON_NULL = "NON_NULL",\n}\n\nexport type __DirectiveLocation =\n    | "QUERY"\n    | "MUTATION"\n    | "SUBSCRIPTION"\n    | "FIELD"\n    | "FRAGMENT_DEFINITION"\n    | "FRAGMENT_SPREAD"\n    | "INLINE_FRAGMENT"\n    | "VARIABLE_DEFINITION"\n    | "SCHEMA"\n    | "SCALAR"\n    | "OBJECT"\n    | "FIELD_DEFINITION"\n    | "ARGUMENT_DEFINITION"\n    | "INTERFACE"\n    | "UNION"\n    | "ENUM"\n    | "ENUM_VALUE"\n    | "INPUT_OBJECT"\n    | "INPUT_FIELD_DEFINITION";\nexport enum __DirectiveLocationEnum {\n    /** Location adjacent to a query operation. */\n    QUERY = "QUERY",\n    /** Location adjacent to a mutation operation. */\n    MUTATION = "MUTATION",\n    /** Location adjacent to a subscription operation. */\n    SUBSCRIPTION = "SUBSCRIPTION",\n    /** Location adjacent to a field. */\n    FIELD = "FIELD",\n    /** Location adjacent to a fragment definition. */\n    FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION",\n    /** Location adjacent to a fragment spread. */\n    FRAGMENT_SPREAD = "FRAGMENT_SPREAD",\n    /** Location adjacent to an inline fragment. */\n    INLINE_FRAGMENT = "INLINE_FRAGMENT",\n    /** Location adjacent to a variable definition. */\n    VARIABLE_DEFINITION = "VARIABLE_DEFINITION",\n    /** Location adjacent to a schema definition. */\n    SCHEMA = "SCHEMA",\n    /** Location adjacent to a scalar definition. */\n    SCALAR = "SCALAR",\n    /** Location adjacent to an object type definition. */\n    OBJECT = "OBJECT",\n    /** Location adjacent to a field definition. */\n    FIELD_DEFINITION = "FIELD_DEFINITION",\n    /** Location adjacent to an argument definition. */\n    ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION",\n    /** Location adjacent to an interface definition. */\n    INTERFACE = "INTERFACE",\n    /** Location adjacent to a union definition. */\n    UNION = "UNION",\n    /** Location adjacent to an enum definition. */\n    ENUM = "ENUM",\n    /** Location adjacent to an enum value definition. */\n    ENUM_VALUE = "ENUM_VALUE",\n    /** Location adjacent to an input object type definition. */\n    INPUT_OBJECT = "INPUT_OBJECT",\n    /** Location adjacent to an input object field definition. */\n    INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION",\n}\n\nexport type __TypeNotNullArrayNotNullFieldsArgs = {\n    includeDeprecated?: boolean;\n};\nexport type __TypeNotNullArrayNotNullEnumValuesArgs = {\n    includeDeprecated?: boolean;\n};\nexport type __TypeNotNullArrayNotNullInputFieldsArgs = {\n    includeDeprecated?: boolean;\n};\nexport type __FieldNotNullArrayArgsArgs = { includeDeprecated?: boolean };\nexport type __TypeNotNullFieldsArgs = { includeDeprecated?: boolean };\nexport type __TypeNotNullEnumValuesArgs = { includeDeprecated?: boolean };\nexport type __TypeNotNullInputFieldsArgs = { includeDeprecated?: boolean };\nexport type __TypeNotNullArrayFieldsArgs = { includeDeprecated?: boolean };\nexport type __TypeNotNullArrayEnumValuesArgs = { includeDeprecated?: boolean };\nexport type __TypeNotNullArrayInputFieldsArgs = { includeDeprecated?: boolean };\nexport type __TypeFieldsArgs = { includeDeprecated?: boolean };\nexport type __TypeEnumValuesArgs = { includeDeprecated?: boolean };\nexport type __TypeInputFieldsArgs = { includeDeprecated?: boolean };\nexport type __DirectiveNotNullArrayNotNullArgsArgs = {\n    includeDeprecated?: boolean;\n};\nexport type __FieldArgsArgs = { includeDeprecated?: boolean };\nexport type __DirectiveArgsArgs = { includeDeprecated?: boolean };\nexport const __TypeNotNullFieldsArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __TypeNotNullArrayFieldsArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __TypeNotNullArrayEnumValuesArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __TypeNotNullArrayInputFieldsArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __TypeFieldsArgsMeta = { includeDeprecated: "Boolean" } as const;\nexport const __TypeEnumValuesArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __TypeInputFieldsArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __TypeNotNullEnumValuesArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __TypeNotNullInputFieldsArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __FieldNotNullArrayArgsArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __TypeNotNullArrayNotNullFieldsArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __TypeNotNullArrayNotNullEnumValuesArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __TypeNotNullArrayNotNullInputFieldsArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __DirectiveNotNullArrayNotNullArgsArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\nexport const __FieldArgsArgsMeta = { includeDeprecated: "Boolean" } as const;\nexport const __DirectiveArgsArgsMeta = {\n    includeDeprecated: "Boolean",\n} as const;\n\nexport type UserSelectionFields = {\n    id?: string;\n    name?: string;\n};\n\nexport type QuerySelectionFields = {\n    user: typeof UserSelection;\n};\n\nexport type __SchemaSelectionFields = {\n    description?: string;\n    /** A list of all types supported by this server. */\n    types: typeof __TypeNotNullArrayNotNullSelection;\n    /** The type that query operations will be rooted at. */\n    queryType: typeof __TypeNotNullSelection;\n    /** If this server supports mutation, the type that mutation operations will be rooted at. */\n    mutationType: typeof __TypeSelection;\n    /** If this server support subscription, the type that subscription operations will be rooted at. */\n    subscriptionType: typeof __TypeSelection;\n    /** A list of all directives supported by this server. */\n    directives: typeof __DirectiveNotNullArrayNotNullSelection;\n};\n\nexport type __TypeNotNullArrayNotNullSelectionFields = {\n    kind: any;\n    name?: string;\n    description?: string;\n    specifiedByURL?: string;\n    fields: (\n        args?: __TypeNotNullArrayNotNullFieldsArgs,\n    ) => typeof __FieldNotNullArraySelection;\n    interfaces: typeof __TypeNotNullArraySelection;\n    possibleTypes: typeof __TypeNotNullArraySelection;\n    enumValues: (\n        args?: __TypeNotNullArrayNotNullEnumValuesArgs,\n    ) => typeof __EnumValueNotNullArraySelection;\n    inputFields: (\n        args?: __TypeNotNullArrayNotNullInputFieldsArgs,\n    ) => typeof __InputValueNotNullArraySelection;\n    ofType: typeof __TypeSelection;\n};\n\nexport type __FieldNotNullArraySelectionFields = {\n    name: string;\n    description?: string;\n    args: (\n        args?: __FieldNotNullArrayArgsArgs,\n    ) => typeof __InputValueNotNullArrayNotNullSelection;\n    type: typeof __TypeNotNullSelection;\n    isDeprecated: boolean;\n    deprecationReason?: string;\n};\n\nexport type __InputValueNotNullArrayNotNullSelectionFields = {\n    name: string;\n    description?: string;\n    type: typeof __TypeNotNullSelection;\n    /** A GraphQL-formatted string representing the default value for this input value. */\n    defaultValue?: string;\n    isDeprecated: boolean;\n    deprecationReason?: string;\n};\n\nexport type __TypeNotNullSelectionFields = {\n    kind: any;\n    name?: string;\n    description?: string;\n    specifiedByURL?: string;\n    fields: (\n        args?: __TypeNotNullFieldsArgs,\n    ) => typeof __FieldNotNullArraySelection;\n    interfaces: typeof __TypeNotNullArraySelection;\n    possibleTypes: typeof __TypeNotNullArraySelection;\n    enumValues: (\n        args?: __TypeNotNullEnumValuesArgs,\n    ) => typeof __EnumValueNotNullArraySelection;\n    inputFields: (\n        args?: __TypeNotNullInputFieldsArgs,\n    ) => typeof __InputValueNotNullArraySelection;\n    ofType: typeof __TypeSelection;\n};\n\nexport type __TypeNotNullArraySelectionFields = {\n    kind: any;\n    name?: string;\n    description?: string;\n    specifiedByURL?: string;\n    fields: (\n        args?: __TypeNotNullArrayFieldsArgs,\n    ) => typeof __FieldNotNullArraySelection;\n    interfaces: typeof __TypeNotNullArraySelection;\n    possibleTypes: typeof __TypeNotNullArraySelection;\n    enumValues: (\n        args?: __TypeNotNullArrayEnumValuesArgs,\n    ) => typeof __EnumValueNotNullArraySelection;\n    inputFields: (\n        args?: __TypeNotNullArrayInputFieldsArgs,\n    ) => typeof __InputValueNotNullArraySelection;\n    ofType: typeof __TypeSelection;\n};\n\nexport type __EnumValueNotNullArraySelectionFields = {\n    name: string;\n    description?: string;\n    isDeprecated: boolean;\n    deprecationReason?: string;\n};\n\nexport type __InputValueNotNullArraySelectionFields = {\n    name: string;\n    description?: string;\n    type: typeof __TypeNotNullSelection;\n    /** A GraphQL-formatted string representing the default value for this input value. */\n    defaultValue?: string;\n    isDeprecated: boolean;\n    deprecationReason?: string;\n};\n\nexport type __TypeSelectionFields = {\n    kind: any;\n    name?: string;\n    description?: string;\n    specifiedByURL?: string;\n    fields: (args?: __TypeFieldsArgs) => typeof __FieldNotNullArraySelection;\n    interfaces: typeof __TypeNotNullArraySelection;\n    possibleTypes: typeof __TypeNotNullArraySelection;\n    enumValues: (\n        args?: __TypeEnumValuesArgs,\n    ) => typeof __EnumValueNotNullArraySelection;\n    inputFields: (\n        args?: __TypeInputFieldsArgs,\n    ) => typeof __InputValueNotNullArraySelection;\n    ofType: typeof __TypeSelection;\n};\n\nexport type __DirectiveNotNullArrayNotNullSelectionFields = {\n    name: string;\n    description?: string;\n    isRepeatable: boolean;\n    locations: Array<any>;\n    args: (\n        args?: __DirectiveNotNullArrayNotNullArgsArgs,\n    ) => typeof __InputValueNotNullArrayNotNullSelection;\n};\n\nexport type __FieldSelectionFields = {\n    name: string;\n    description?: string;\n    args: (\n        args?: __FieldArgsArgs,\n    ) => typeof __InputValueNotNullArrayNotNullSelection;\n    type: typeof __TypeNotNullSelection;\n    isDeprecated: boolean;\n    deprecationReason?: string;\n};\n\nexport type __InputValueSelectionFields = {\n    name: string;\n    description?: string;\n    type: typeof __TypeNotNullSelection;\n    /** A GraphQL-formatted string representing the default value for this input value. */\n    defaultValue?: string;\n    isDeprecated: boolean;\n    deprecationReason?: string;\n};\n\nexport type __EnumValueSelectionFields = {\n    name: string;\n    description?: string;\n    isDeprecated: boolean;\n    deprecationReason?: string;\n};\n\nexport type __DirectiveSelectionFields = {\n    name: string;\n    description?: string;\n    isRepeatable: boolean;\n    locations: Array<any>;\n    args: (\n        args?: __DirectiveArgsArgs,\n    ) => typeof __InputValueNotNullArrayNotNullSelection;\n};\n\nexport function makeUserSelectionInput(this: any) {\n    return {\n        id: new SelectionWrapper("id", "ID", {}, this),\n        name: new SelectionWrapper("name", "String", {}, this),\n    } as const;\n}\nexport function UserSelection<T extends object, F extends UserSelectionFields>(\n    this: any,\n    s: (selection: F) => T,\n) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = makeUserSelectionInput.bind(this)() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "User",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T;\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector("UserSelection", parent?.collector),\n    )();\n}\n\nnew SelectionWrapper("id", "ID", {}, this);\nnew SelectionWrapper("description", "String", {}, this);\n\nexport function makeQuerySelectionInput(this: any) {\n    return {\n        user: UserSelection.bind({ collector: this, fieldName: "user" }),\n    } as const;\n}\nexport function QuerySelection<\n    T extends object,\n    F extends QuerySelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = makeQuerySelectionInput.bind(this)() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "Query",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T;\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector("QuerySelection", parent?.collector),\n    )();\n}\n\nexport function make__TypeNotNullArrayNotNullSelectionInput(this: any) {\n    return {\n        kind: new SelectionWrapper("kind", "__TypeKind!", {}, this),\n        name: new SelectionWrapper("name", "String", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        specifiedByURL: new SelectionWrapper(\n            "specifiedByURL",\n            "String",\n            {},\n            this,\n        ),\n        fields: (args: __TypeNotNullArrayNotNullFieldsArgs) =>\n            __FieldNotNullArraySelection.bind({\n                collector: this,\n                fieldName: "fields",\n                args,\n                argsMeta: __TypeNotNullArrayNotNullFieldsArgsMeta,\n            }),\n        interfaces: __TypeNotNullArraySelection.bind({\n            collector: this,\n            fieldName: "interfaces",\n        }),\n        possibleTypes: __TypeNotNullArraySelection.bind({\n            collector: this,\n            fieldName: "possibleTypes",\n        }),\n        enumValues: (args: __TypeNotNullArrayNotNullEnumValuesArgs) =>\n            __EnumValueNotNullArraySelection.bind({\n                collector: this,\n                fieldName: "enumValues",\n                args,\n                argsMeta: __TypeNotNullArrayNotNullEnumValuesArgsMeta,\n            }),\n        inputFields: (args: __TypeNotNullArrayNotNullInputFieldsArgs) =>\n            __InputValueNotNullArraySelection.bind({\n                collector: this,\n                fieldName: "inputFields",\n                args,\n                argsMeta: __TypeNotNullArrayNotNullInputFieldsArgsMeta,\n            }),\n        ofType: __TypeSelection.bind({ collector: this, fieldName: "ofType" }),\n    } as const;\n}\nexport function __TypeNotNullArrayNotNullSelection<\n    T extends object,\n    F extends __TypeNotNullArrayNotNullSelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = make__TypeNotNullArrayNotNullSelectionInput.bind(\n            this,\n        )() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "[__Type!]!",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T[];\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector(\n            "__TypeNotNullArrayNotNullSelection",\n            parent?.collector,\n        ),\n    )();\n}\n\nexport function make__FieldNotNullArraySelectionInput(this: any) {\n    return {\n        name: new SelectionWrapper("name", "String!", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        args: (args: __FieldNotNullArrayArgsArgs) =>\n            __InputValueNotNullArrayNotNullSelection.bind({\n                collector: this,\n                fieldName: "args",\n                args,\n                argsMeta: __FieldNotNullArrayArgsArgsMeta,\n            }),\n        type: __TypeNotNullSelection.bind({\n            collector: this,\n            fieldName: "type",\n        }),\n        isDeprecated: new SelectionWrapper(\n            "isDeprecated",\n            "Boolean!",\n            {},\n            this,\n        ),\n        deprecationReason: new SelectionWrapper(\n            "deprecationReason",\n            "String",\n            {},\n            this,\n        ),\n    } as const;\n}\nexport function __FieldNotNullArraySelection<\n    T extends object,\n    F extends __FieldNotNullArraySelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = make__FieldNotNullArraySelectionInput.bind(\n            this,\n        )() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "[__Field!]",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T[];\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector(\n            "__FieldNotNullArraySelection",\n            parent?.collector,\n        ),\n    )();\n}\n\nnew SelectionWrapper("name", "String!", {}, this);\n\nexport function make__InputValueNotNullArrayNotNullSelectionInput(this: any) {\n    return {\n        name: new SelectionWrapper("name", "String!", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        type: __TypeNotNullSelection.bind({\n            collector: this,\n            fieldName: "type",\n        }),\n        defaultValue: new SelectionWrapper("defaultValue", "String", {}, this),\n        isDeprecated: new SelectionWrapper(\n            "isDeprecated",\n            "Boolean!",\n            {},\n            this,\n        ),\n        deprecationReason: new SelectionWrapper(\n            "deprecationReason",\n            "String",\n            {},\n            this,\n        ),\n    } as const;\n}\nexport function __InputValueNotNullArrayNotNullSelection<\n    T extends object,\n    F extends __InputValueNotNullArrayNotNullSelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F =\n            make__InputValueNotNullArrayNotNullSelectionInput.bind(\n                this,\n            )() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "[__InputValue!]!",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T[];\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector(\n            "__InputValueNotNullArrayNotNullSelection",\n            parent?.collector,\n        ),\n    )();\n}\n\nexport function make__TypeNotNullSelectionInput(this: any) {\n    return {\n        kind: new SelectionWrapper("kind", "__TypeKind!", {}, this),\n        name: new SelectionWrapper("name", "String", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        specifiedByURL: new SelectionWrapper(\n            "specifiedByURL",\n            "String",\n            {},\n            this,\n        ),\n        fields: (args: __TypeNotNullFieldsArgs) =>\n            __FieldNotNullArraySelection.bind({\n                collector: this,\n                fieldName: "fields",\n                args,\n                argsMeta: __TypeNotNullFieldsArgsMeta,\n            }),\n        interfaces: __TypeNotNullArraySelection.bind({\n            collector: this,\n            fieldName: "interfaces",\n        }),\n        possibleTypes: __TypeNotNullArraySelection.bind({\n            collector: this,\n            fieldName: "possibleTypes",\n        }),\n        enumValues: (args: __TypeNotNullEnumValuesArgs) =>\n            __EnumValueNotNullArraySelection.bind({\n                collector: this,\n                fieldName: "enumValues",\n                args,\n                argsMeta: __TypeNotNullEnumValuesArgsMeta,\n            }),\n        inputFields: (args: __TypeNotNullInputFieldsArgs) =>\n            __InputValueNotNullArraySelection.bind({\n                collector: this,\n                fieldName: "inputFields",\n                args,\n                argsMeta: __TypeNotNullInputFieldsArgsMeta,\n            }),\n        ofType: __TypeSelection.bind({ collector: this, fieldName: "ofType" }),\n    } as const;\n}\nexport function __TypeNotNullSelection<\n    T extends object,\n    F extends __TypeNotNullSelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = make__TypeNotNullSelectionInput.bind(\n            this,\n        )() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "__Type!",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T;\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector(\n            "__TypeNotNullSelection",\n            parent?.collector,\n        ),\n    )();\n}\n\nexport function make__TypeNotNullArraySelectionInput(this: any) {\n    return {\n        kind: new SelectionWrapper("kind", "__TypeKind!", {}, this),\n        name: new SelectionWrapper("name", "String", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        specifiedByURL: new SelectionWrapper(\n            "specifiedByURL",\n            "String",\n            {},\n            this,\n        ),\n        fields: (args: __TypeNotNullArrayFieldsArgs) =>\n            __FieldNotNullArraySelection.bind({\n                collector: this,\n                fieldName: "fields",\n                args,\n                argsMeta: __TypeNotNullArrayFieldsArgsMeta,\n            }),\n        interfaces: __TypeNotNullArraySelection.bind({\n            collector: this,\n            fieldName: "interfaces",\n        }),\n        possibleTypes: __TypeNotNullArraySelection.bind({\n            collector: this,\n            fieldName: "possibleTypes",\n        }),\n        enumValues: (args: __TypeNotNullArrayEnumValuesArgs) =>\n            __EnumValueNotNullArraySelection.bind({\n                collector: this,\n                fieldName: "enumValues",\n                args,\n                argsMeta: __TypeNotNullArrayEnumValuesArgsMeta,\n            }),\n        inputFields: (args: __TypeNotNullArrayInputFieldsArgs) =>\n            __InputValueNotNullArraySelection.bind({\n                collector: this,\n                fieldName: "inputFields",\n                args,\n                argsMeta: __TypeNotNullArrayInputFieldsArgsMeta,\n            }),\n        ofType: __TypeSelection.bind({ collector: this, fieldName: "ofType" }),\n    } as const;\n}\nexport function __TypeNotNullArraySelection<\n    T extends object,\n    F extends __TypeNotNullArraySelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = make__TypeNotNullArraySelectionInput.bind(\n            this,\n        )() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "[__Type!]",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T[];\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector(\n            "__TypeNotNullArraySelection",\n            parent?.collector,\n        ),\n    )();\n}\n\nexport function make__EnumValueNotNullArraySelectionInput(this: any) {\n    return {\n        name: new SelectionWrapper("name", "String!", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        isDeprecated: new SelectionWrapper(\n            "isDeprecated",\n            "Boolean!",\n            {},\n            this,\n        ),\n        deprecationReason: new SelectionWrapper(\n            "deprecationReason",\n            "String",\n            {},\n            this,\n        ),\n    } as const;\n}\nexport function __EnumValueNotNullArraySelection<\n    T extends object,\n    F extends __EnumValueNotNullArraySelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = make__EnumValueNotNullArraySelectionInput.bind(\n            this,\n        )() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "[__EnumValue!]",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T[];\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector(\n            "__EnumValueNotNullArraySelection",\n            parent?.collector,\n        ),\n    )();\n}\n\nnew SelectionWrapper("isRepeatable", "Boolean!", {}, this);\n\nexport function make__InputValueNotNullArraySelectionInput(this: any) {\n    return {\n        name: new SelectionWrapper("name", "String!", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        type: __TypeNotNullSelection.bind({\n            collector: this,\n            fieldName: "type",\n        }),\n        defaultValue: new SelectionWrapper("defaultValue", "String", {}, this),\n        isDeprecated: new SelectionWrapper(\n            "isDeprecated",\n            "Boolean!",\n            {},\n            this,\n        ),\n        deprecationReason: new SelectionWrapper(\n            "deprecationReason",\n            "String",\n            {},\n            this,\n        ),\n    } as const;\n}\nexport function __InputValueNotNullArraySelection<\n    T extends object,\n    F extends __InputValueNotNullArraySelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = make__InputValueNotNullArraySelectionInput.bind(\n            this,\n        )() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "[__InputValue!]",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T[];\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector(\n            "__InputValueNotNullArraySelection",\n            parent?.collector,\n        ),\n    )();\n}\n\nexport function make__TypeSelectionInput(this: any) {\n    return {\n        kind: new SelectionWrapper("kind", "__TypeKind!", {}, this),\n        name: new SelectionWrapper("name", "String", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        specifiedByURL: new SelectionWrapper(\n            "specifiedByURL",\n            "String",\n            {},\n            this,\n        ),\n        fields: (args: __TypeFieldsArgs) =>\n            __FieldNotNullArraySelection.bind({\n                collector: this,\n                fieldName: "fields",\n                args,\n                argsMeta: __TypeFieldsArgsMeta,\n            }),\n        interfaces: __TypeNotNullArraySelection.bind({\n            collector: this,\n            fieldName: "interfaces",\n        }),\n        possibleTypes: __TypeNotNullArraySelection.bind({\n            collector: this,\n            fieldName: "possibleTypes",\n        }),\n        enumValues: (args: __TypeEnumValuesArgs) =>\n            __EnumValueNotNullArraySelection.bind({\n                collector: this,\n                fieldName: "enumValues",\n                args,\n                argsMeta: __TypeEnumValuesArgsMeta,\n            }),\n        inputFields: (args: __TypeInputFieldsArgs) =>\n            __InputValueNotNullArraySelection.bind({\n                collector: this,\n                fieldName: "inputFields",\n                args,\n                argsMeta: __TypeInputFieldsArgsMeta,\n            }),\n        ofType: __TypeSelection.bind({ collector: this, fieldName: "ofType" }),\n    } as const;\n}\nexport function __TypeSelection<\n    T extends object,\n    F extends __TypeSelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = make__TypeSelectionInput.bind(this)() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "__Type",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T;\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector("__TypeSelection", parent?.collector),\n    )();\n}\n\nexport function make__DirectiveNotNullArrayNotNullSelectionInput(this: any) {\n    return {\n        name: new SelectionWrapper("name", "String!", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        isRepeatable: new SelectionWrapper(\n            "isRepeatable",\n            "Boolean!",\n            {},\n            this,\n        ),\n        locations: new SelectionWrapper(\n            "locations",\n            "[__DirectiveLocation!]!",\n            {},\n            this,\n        ),\n        args: (args: __DirectiveNotNullArrayNotNullArgsArgs) =>\n            __InputValueNotNullArrayNotNullSelection.bind({\n                collector: this,\n                fieldName: "args",\n                args,\n                argsMeta: __DirectiveNotNullArrayNotNullArgsArgsMeta,\n            }),\n    } as const;\n}\nexport function __DirectiveNotNullArrayNotNullSelection<\n    T extends object,\n    F extends __DirectiveNotNullArrayNotNullSelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F =\n            make__DirectiveNotNullArrayNotNullSelectionInput.bind(\n                this,\n            )() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "[__Directive!]!",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T[];\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector(\n            "__DirectiveNotNullArrayNotNullSelection",\n            parent?.collector,\n        ),\n    )();\n}\n\nexport function make__SchemaSelectionInput(this: any) {\n    return {\n        description: new SelectionWrapper("description", "String", {}, this),\n        types: __TypeNotNullArrayNotNullSelection.bind({\n            collector: this,\n            fieldName: "types",\n        }),\n        queryType: __TypeNotNullSelection.bind({\n            collector: this,\n            fieldName: "queryType",\n        }),\n        mutationType: __TypeSelection.bind({\n            collector: this,\n            fieldName: "mutationType",\n        }),\n        subscriptionType: __TypeSelection.bind({\n            collector: this,\n            fieldName: "subscriptionType",\n        }),\n        directives: __DirectiveNotNullArrayNotNullSelection.bind({\n            collector: this,\n            fieldName: "directives",\n        }),\n    } as const;\n}\nexport function __SchemaSelection<\n    T extends object,\n    F extends __SchemaSelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = make__SchemaSelectionInput.bind(this)() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "__Schema",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T;\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector("__SchemaSelection", parent?.collector),\n    )();\n}\n\nexport function make__FieldSelectionInput(this: any) {\n    return {\n        name: new SelectionWrapper("name", "String!", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        args: (args: __FieldArgsArgs) =>\n            __InputValueNotNullArrayNotNullSelection.bind({\n                collector: this,\n                fieldName: "args",\n                args,\n                argsMeta: __FieldArgsArgsMeta,\n            }),\n        type: __TypeNotNullSelection.bind({\n            collector: this,\n            fieldName: "type",\n        }),\n        isDeprecated: new SelectionWrapper(\n            "isDeprecated",\n            "Boolean!",\n            {},\n            this,\n        ),\n        deprecationReason: new SelectionWrapper(\n            "deprecationReason",\n            "String",\n            {},\n            this,\n        ),\n    } as const;\n}\nexport function __FieldSelection<\n    T extends object,\n    F extends __FieldSelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = make__FieldSelectionInput.bind(this)() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "__Field",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T;\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector("__FieldSelection", parent?.collector),\n    )();\n}\n\nexport function make__InputValueSelectionInput(this: any) {\n    return {\n        name: new SelectionWrapper("name", "String!", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        type: __TypeNotNullSelection.bind({\n            collector: this,\n            fieldName: "type",\n        }),\n        defaultValue: new SelectionWrapper("defaultValue", "String", {}, this),\n        isDeprecated: new SelectionWrapper(\n            "isDeprecated",\n            "Boolean!",\n            {},\n            this,\n        ),\n        deprecationReason: new SelectionWrapper(\n            "deprecationReason",\n            "String",\n            {},\n            this,\n        ),\n    } as const;\n}\nexport function __InputValueSelection<\n    T extends object,\n    F extends __InputValueSelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = make__InputValueSelectionInput.bind(this)() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "__InputValue",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T;\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector(\n            "__InputValueSelection",\n            parent?.collector,\n        ),\n    )();\n}\n\nexport function make__EnumValueSelectionInput(this: any) {\n    return {\n        name: new SelectionWrapper("name", "String!", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        isDeprecated: new SelectionWrapper(\n            "isDeprecated",\n            "Boolean!",\n            {},\n            this,\n        ),\n        deprecationReason: new SelectionWrapper(\n            "deprecationReason",\n            "String",\n            {},\n            this,\n        ),\n    } as const;\n}\nexport function __EnumValueSelection<\n    T extends object,\n    F extends __EnumValueSelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = make__EnumValueSelectionInput.bind(this)() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "__EnumValue",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T;\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector(\n            "__EnumValueSelection",\n            parent?.collector,\n        ),\n    )();\n}\n\nexport function make__DirectiveSelectionInput(this: any) {\n    return {\n        name: new SelectionWrapper("name", "String!", {}, this),\n        description: new SelectionWrapper("description", "String", {}, this),\n        isRepeatable: new SelectionWrapper(\n            "isRepeatable",\n            "Boolean!",\n            {},\n            this,\n        ),\n        locations: new SelectionWrapper(\n            "locations",\n            "[__DirectiveLocation!]!",\n            {},\n            this,\n        ),\n        args: (args: __DirectiveArgsArgs) =>\n            __InputValueNotNullArrayNotNullSelection.bind({\n                collector: this,\n                fieldName: "args",\n                args,\n                argsMeta: __DirectiveArgsArgsMeta,\n            }),\n    } as const;\n}\nexport function __DirectiveSelection<\n    T extends object,\n    F extends __DirectiveSelectionFields,\n>(this: any, s: (selection: F) => T) {\n    let parent: SelectionFnParent = this ?? {\n        collector: new OperationSelectionCollector(),\n    };\n    function innerFn(this: any) {\n        const selection: F = make__DirectiveSelectionInput.bind(this)() as any;\n        const r = s(selection);\n        const result = new SelectionWrapper(\n            parent?.fieldName,\n            "__Directive",\n            r,\n            this,\n            parent?.collector,\n            parent?.args,\n            parent?.argsMeta,\n        ) as unknown as T;\n        Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n        return result;\n    }\n    return innerFn.bind(\n        new OperationSelectionCollector(\n            "__DirectiveSelection",\n            parent?.collector,\n        ),\n    )();\n}\n\nexport type _RootOperationSelectionFields = {\n    query: typeof QuerySelection;\n};\nexport function _makeRootOperationInput(this: any) {\n    return {\n        query: QuerySelection.bind({\n            collector: this,\n        }),\n    } as const;\n}\nexport default function <\n    T extends object,\n    F extends _RootOperationSelectionFields,\n>(this: any, s: (selection: F) => T) {\n    const root = new OperationSelectionCollector(\n        undefined,\n        undefined,\n        new RootOperation(),\n    );\n    const selection: F = _makeRootOperationInput.bind(root)() as any;\n    const r = s(selection);\n    const result = new SelectionWrapper(\n        undefined,\n        undefined,\n        r,\n        root,\n        undefined,\n    ) as unknown as T;\n    Object.keys(r).forEach((key) => (result as T)[key as keyof T]);\n    return new Promise((resolve, reject) => {\n        root.execute()\n            .then(() => {\n                resolve(result);\n            })\n            .catch((err) => {\n                reject(err);\n            });\n    }) as Promise<T>;\n}\n',
            );
        });

        // Add more test cases for different scenarios...
    });
});
